package org.batfish.z3;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import org.batfish.datamodel.HeaderSpace;
import org.batfish.datamodel.IpAccessListLine;
import org.batfish.datamodel.LineAction;
import org.batfish.datamodel.acl.AclLineMatchExpr;
import org.batfish.datamodel.acl.AndMatchExpr;
import org.batfish.datamodel.acl.FalseExpr;
import org.batfish.datamodel.acl.GenericAclLineMatchExprVisitor;
import org.batfish.datamodel.acl.MatchHeaderSpace;
import org.batfish.datamodel.acl.MatchSrcInterface;
import org.batfish.datamodel.acl.NotMatchExpr;
import org.batfish.datamodel.acl.OrMatchExpr;
import org.batfish.datamodel.acl.OriginatingFromDevice;
import org.batfish.datamodel.acl.PermittedByAcl;
import org.batfish.datamodel.acl.TrueExpr;

/**
 * Given a starting header space, this visitor returns an AclLineMatchExpr representing the
 * specialized version of that header space relative to the line visited. This is useful for
 * specializing a MatchHeaderSpace line in an ACL that may partially block a later line.
 */
public class HeaderSpaceSpecializerByLine
    implements GenericAclLineMatchExprVisitor<AclLineMatchExpr> {
  private final HeaderSpace _headerSpace;

  public HeaderSpaceSpecializerByLine(HeaderSpace headerSpace) {
    _headerSpace = headerSpace;
  }

  @Override
  public AclLineMatchExpr visitAndMatchExpr(AndMatchExpr andMatchExpr) {
    List<AclLineMatchExpr> conjuncts =
        andMatchExpr
            .getConjuncts()
            .parallelStream()
            .map(expr -> expr.accept(this))
            .filter(expr -> expr != TrueExpr.INSTANCE)
            .collect(ImmutableList.toImmutableList());
    if (conjuncts.isEmpty()) {
      return TrueExpr.INSTANCE;
    }
    return conjuncts.contains(FalseExpr.INSTANCE)
        ? FalseExpr.INSTANCE
        : new AndMatchExpr(conjuncts);
  }

  @Override
  public AclLineMatchExpr visitFalseExpr(FalseExpr falseExpr) {
    return falseExpr;
  }

  @Override
  public AclLineMatchExpr visitMatchHeaderSpace(MatchHeaderSpace matchHeaderSpace) {
    IpAccessListSpecializer specializer =
        new IpAccessListSpecializer(matchHeaderSpace.getHeaderspace(), ImmutableMap.of());
    Optional<IpAccessListLine> specialized =
        specializer.specialize(
            new IpAccessListLine(LineAction.ACCEPT, new MatchHeaderSpace(_headerSpace), ""));
    return specialized.isPresent() ? specialized.get().getMatchCondition() : FalseExpr.INSTANCE;
  }

  @Override
  public AclLineMatchExpr visitMatchSrcInterface(MatchSrcInterface matchSrcInterface) {
    /* MatchHeaderSpace should never overlap with MatchSrcInterface */
    /* TODO What if _headerSpace matches every header space and thereby blocks all later lines? */
    return FalseExpr.INSTANCE;
  }

  @Override
  public AclLineMatchExpr visitNotMatchExpr(NotMatchExpr notMatchExpr) {
    AclLineMatchExpr subExpr = notMatchExpr.getOperand().accept(this);

    if (subExpr == TrueExpr.INSTANCE) {
      return FalseExpr.INSTANCE;
    } else if (subExpr == FalseExpr.INSTANCE) {
      return TrueExpr.INSTANCE;
    } else {
      return new NotMatchExpr(subExpr);
    }
  }

  @Override
  public AclLineMatchExpr visitOriginatingFromDevice(OriginatingFromDevice originatingFromDevice) {
    /* MatchHeaderSpace should never overlap with OriginatingFromDevice */
    /* TODO What if _headerSpace matches every header space and thereby blocks all later lines? */
    return FalseExpr.INSTANCE;
  }

  @Override
  public AclLineMatchExpr visitOrMatchExpr(OrMatchExpr orMatchExpr) {

    List<AclLineMatchExpr> specializedDisjuncts = new ArrayList<>();
    boolean allTrueExpr = true;
    /*
    Represent the specialized header space with a new OrMatchExpr. For each original disjunct:
    - If it specializes the header space to FalseExpr, don't add a specialized disjunct
    - If it specializes the header space to TrueExpr, add the original disjunct
    - Otherwise, add the AclLineMatchExpr generated by specializing the header space w/ the disjunct
     */
    for (AclLineMatchExpr disjunct : orMatchExpr.getDisjuncts()) {
      AclLineMatchExpr specialized = disjunct.accept(this);
      if (specialized == TrueExpr.INSTANCE) {
        // Disjunct specialized header space into TrueExpr. If a packet matches this disjunct, it
        // will also match the header space.
        specializedDisjuncts.add(disjunct);
      } else {
        allTrueExpr = false;
        if (specialized != FalseExpr.INSTANCE) {
          specializedDisjuncts.add(specialized);
        }
      }
    }

    if (specializedDisjuncts.isEmpty()) {
      // All disjuncts specialized header space into FalseExpr.
      return FalseExpr.INSTANCE;
    } else if (allTrueExpr) {
      // Header space fully matches all disjuncts.
      return TrueExpr.INSTANCE;
    } else if (specializedDisjuncts.size() == 1) {
      // Only one disjunct was matchable by the header space. Return that specialized disjunct.
      return specializedDisjuncts.get(0);
    }
    return new OrMatchExpr(specializedDisjuncts);
  }

  @Override
  public AclLineMatchExpr visitPermittedByAcl(PermittedByAcl permittedByAcl) {
    // TODO lazy
    return new MatchHeaderSpace(_headerSpace);
  }

  @Override
  public AclLineMatchExpr visitTrueExpr(TrueExpr trueExpr) {
    return FalseExpr.INSTANCE;
  }
}
