package org.batfish.bddreachability;

import static org.batfish.common.util.CommonUtil.toImmutableMap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.sf.javabdd.BDD;
import org.batfish.common.BatfishException;
import org.batfish.common.bdd.BDDPacket;
import org.batfish.datamodel.Flow;
import org.batfish.datamodel.Flow.Builder;
import org.batfish.z3.IngressLocation;
import org.batfish.z3.expr.StateExpr;
import org.batfish.z3.state.Accept;
import org.batfish.z3.state.Drop;
import org.batfish.z3.state.NeighborUnreachable;
import org.batfish.z3.state.OriginateInterfaceLink;
import org.batfish.z3.state.OriginateVrf;
import org.batfish.z3.state.visitors.DefaultTransitionGenerator;

/**
 * A new reachability analysis engine using BDDs. The analysis maintains a graph that describes how
 * packets flow through the network and through logical phases of a router. The graph is similar to
 * the one generated by {@link DefaultTransitionGenerator} for reachability analysis using NOD. In
 * particular, the graph nodes are {@link StateExpr StateExprs} and the edges are mostly the same as
 * the NOD program rules/transitions. {@link BDD BDDs} label the nodes and edges of the graph. A
 * node label represent the set of packets that can reach that node, and an edge label represents
 * the set of packets that can traverse the edge.
 *
 * <p>The two main departures from the NOD program are: 1) ACLs are encoded as a single BDD that
 * labels an edge (rather than a series of states/transitions in NOD programs). 2) Source NAT is
 * handled differently -- we don't maintain separate original and current source IP variables.
 * Instead, we keep track of where/how the packet is transformed as it flows through the network,
 * and reconstruct it after the fact. This requires some work that can't be expressed in BDDs.
 *
 * <p>We currently implement backward all-pairs reachability. Forward reachability is useful for
 * questions with a tight source constraint, e.g. "find me packets send from node A that get
 * dropped". When reasoning about many sources simultaneously, we have to somehow remember the
 * source, which is very expensive for a large number of sources. Something like multipath
 * consistency -- "find me a packet and a node such that when the node sends the packet, it can be
 * either accepted and dropped" -- for which there are many sources but only a few sinks ({@link
 * Accept}, {@link Drop}, and {@link NeighborUnreachable}), backward reachability is much more
 * efficient. We still have to remember the sinks, but there's only ever 3 of those, no matter how
 * many sources there are.
 */
public class BDDReachabilityAnalysis {
  private final BDDPacket _bddPacket;

  // preState --> postState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _edges;

  // postState --> preState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _reverseEdges;

  private final ImmutableSet<StateExpr> _graphRoots;

  private Set<StateExpr> _leafStates;

  BDDReachabilityAnalysis(
      BDDPacket packet, Set<StateExpr> graphRoots, Map<StateExpr, Map<StateExpr, Edge>> edges) {
    _bddPacket = packet;
    _edges = edges;
    _reverseEdges = computeReverseEdges(_edges);
    _graphRoots = ImmutableSet.copyOf(graphRoots);
    _leafStates = computeTerminalStates();
  }

  private static Map<StateExpr, Map<StateExpr, Edge>> computeReverseEdges(
      Map<StateExpr, Map<StateExpr, Edge>> edges) {
    Map<StateExpr, Map<StateExpr, Edge>> reverseEdges = new HashMap<>();
    edges.forEach(
        (preState, preStateOutEdges) ->
            preStateOutEdges.forEach(
                (postState, edge) ->
                    reverseEdges
                        .computeIfAbsent(postState, k -> new HashMap<>())
                        .put(preState, edge)));
    // freeze
    return toImmutableMap(
        reverseEdges, Entry::getKey, entry -> ImmutableMap.copyOf(entry.getValue()));
  }

  private Map<StateExpr, Map<StateExpr, BDD>> computeReverseReachableStates(
      List<StateExpr> leaves) {
    Map<StateExpr, Map<StateExpr, BDD>> reverseReachableStates = new HashMap<>();
    Multimap<StateExpr, StateExpr> dirty = HashMultimap.create();
    for (StateExpr leaf : leaves) {
      reverseReachableStates.put(leaf, ImmutableMap.of(leaf, _bddPacket.getFactory().one()));
      dirty.put(leaf, leaf);
    }

    List<Long> roundTimes = new LinkedList<>();
    List<Integer> roundDirties = new LinkedList<>();

    while (!dirty.isEmpty()) {
      Multimap<StateExpr, StateExpr> newDirty = HashMultimap.create();
      long time = System.currentTimeMillis();

      dirty.forEach(
          (postState, leaf) -> {
            Map<StateExpr, Edge> postStateInEdges = _reverseEdges.get(postState);
            if (postStateInEdges == null) {
              // postState has no in-edges
              return;
            }

            BDD postStateBDD = reverseReachableStates.get(postState).get(leaf);
            postStateInEdges.forEach(
                (preState, edge) -> {
                  BDD result = edge.traverseBackward(postStateBDD);
                  if (result.isZero()) {
                    return;
                  }

                  // update preState BDD reverse-reachable from leaf
                  Map<StateExpr, BDD> reverseReachPreState =
                      reverseReachableStates.computeIfAbsent(preState, k -> new HashMap<>());
                  BDD oldReach = reverseReachPreState.get(leaf);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);

                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reverseReachPreState.put(leaf, newReach);
                    newDirty.put(preState, leaf);
                  }
                });
          });

      dirty = newDirty;

      time = System.currentTimeMillis() - time;
      roundTimes.add(time);
      roundDirties.add(dirty.size());
    }

    return toImmutableMap(
        reverseReachableStates,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Set<StateExpr> computeTerminalStates() {
    Set<StateExpr> preStates = _edges.keySet();
    Set<StateExpr> postStates =
        _edges.values().stream().flatMap(m -> m.keySet().stream()).collect(Collectors.toSet());
    return ImmutableSet.copyOf(Sets.difference(postStates, preStates));
  }

  /**
   * Return a list of {@link MultipathInconsistency multipath consistency violations} detected in
   * the network.
   */
  @VisibleForTesting
  List<MultipathInconsistency> computeMultipathInconsistencies() {
    return computeReverseReachableStates(
            ImmutableList.of(Accept.INSTANCE, Drop.INSTANCE, NeighborUnreachable.INSTANCE))
        .entrySet()
        .stream()
        .filter(entry -> _graphRoots.contains(entry.getKey()))
        .flatMap(
            entry -> {
              StateExpr root = entry.getKey();
              Map<StateExpr, BDD> leafBDDs = entry.getValue();
              return _leafStates
                  .stream()
                  .filter(leafBDDs::containsKey)
                  .flatMap(
                      leaf1 -> {
                        BDD leaf1BDD = leafBDDs.get(leaf1);
                        return _leafStates
                            .stream()
                            .filter(leaf2 -> leaf1 != leaf2)
                            .filter(leafBDDs::containsKey)
                            // avoid duplicate violations
                            .filter(leaf2 -> leaf1.toString().compareTo(leaf2.toString()) < 1)
                            .flatMap(
                                leaf2 -> {
                                  BDD leaf2BDD = leafBDDs.get(leaf2);
                                  BDD intersection = leaf1BDD.and(leaf2BDD);
                                  return intersection.isZero()
                                      ? Stream.empty()
                                      : Stream.of(
                                          new MultipathInconsistency(
                                              root, ImmutableSet.of(leaf1, leaf2), intersection));
                                });
                      });
            })
        .collect(ImmutableList.toImmutableList());
  }

  public Map<IngressLocation, BDD> getIngressLocationAcceptBDDs() {
    BDD zero = _bddPacket.getFactory().zero();
    Map<StateExpr, Map<StateExpr, BDD>> reverseReachableStates =
        computeReverseReachableStates(ImmutableList.of(Accept.INSTANCE));
    return _graphRoots
        .stream()
        .collect(
            ImmutableMap.toImmutableMap(
                BDDReachabilityAnalysis::toIngressLocation,
                root ->
                    reverseReachableStates
                        .getOrDefault(root, ImmutableMap.of())
                        .getOrDefault(Accept.INSTANCE, zero)));
  }

  @VisibleForTesting
  static IngressLocation toIngressLocation(StateExpr stateExpr) {
    Preconditions.checkArgument(
        stateExpr instanceof OriginateVrf || stateExpr instanceof OriginateInterfaceLink);

    if (stateExpr instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) stateExpr;
      return IngressLocation.vrf(originateVrf.getHostname(), originateVrf.getVrf());
    } else {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) stateExpr;
      return IngressLocation.interfaceLink(
          originateInterfaceLink.getHostname(), originateInterfaceLink.getIface());
    }
  }

  Set<StateExpr> getLeafStates() {
    return _leafStates;
  }

  public Set<Flow> multipathInconsistencies(String flowTag) {
    return computeMultipathInconsistencies()
        .stream()
        .map(violation -> multipathInconsistencyToFlow(violation, flowTag))
        .collect(ImmutableSet.toImmutableSet());
  }

  @VisibleForTesting
  Flow multipathInconsistencyToFlow(MultipathInconsistency violation, String flowTag) {
    Builder fb =
        _bddPacket
            .getFlow(violation.getBDD())
            .orElseGet(
                () -> {
                  throw new BatfishException("MultipathConsistencyViolation with UNSAT predicate");
                });
    StateExpr originateState = violation.getOriginateState();
    fb.setTag(flowTag);
    if (originateState instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) originateState;
      fb.setIngressNode(originateVrf.getHostname());
      fb.setIngressVrf(originateVrf.getVrf());
    } else if (originateState instanceof OriginateInterfaceLink) {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) originateState;
      fb.setIngressNode(originateInterfaceLink.getHostname());
      fb.setIngressInterface(originateInterfaceLink.getIface());
    } else {
      throw new BatfishException(
          "Unexpected originateState type: " + originateState.getClass().getSimpleName());
    }
    return fb.build();
  }

  @VisibleForTesting
  Map<StateExpr, Map<StateExpr, Edge>> getEdges() {
    return _edges;
  }
}
