package org.batfish.bddreachability;

import static org.batfish.common.util.CommonUtil.toImmutableMap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Function;
import net.sf.javabdd.BDD;
import org.batfish.common.bdd.BDDPacket;
import org.batfish.z3.IngressLocation;
import org.batfish.z3.expr.StateExpr;
import org.batfish.z3.state.OriginateInterfaceLink;
import org.batfish.z3.state.OriginateVrf;
import org.batfish.z3.state.Query;
import org.batfish.z3.state.visitors.DefaultTransitionGenerator;

/**
 * A new reachability analysis engine using BDDs. The analysis maintains a graph that describes how
 * packets flow through the network and through logical phases of a router. The graph is similar to
 * the one generated by {@link DefaultTransitionGenerator} for reachability analysis using NOD. In
 * particular, the graph nodes are {@link StateExpr StateExprs} and the edges are mostly the same as
 * the NOD program rules/transitions. {@link BDD BDDs} label the nodes and edges of the graph. A
 * node label represent the set of packets that can reach that node, and an edge label represents
 * the set of packets that can traverse the edge. There is a single designated {@link Query}
 * StateExpr that we compute reachability sets (i.e. sets of packets that reach the query state).
 * The query state never has any out-edges, and has in-edges from the dispositions of interest.
 *
 * <p>The two main departures from the NOD program are: 1) ACLs are encoded as a single BDD that
 * labels an edge (rather than a series of states/transitions in NOD programs). 2) Source NAT is
 * handled differently -- we don't maintain separate original and current source IP variables.
 * Instead, we keep track of where/how the packet is transformed as it flows through the network,
 * and reconstruct it after the fact. This requires some work that can't be expressed in BDDs.
 *
 * <p>We currently implement backward all-pairs reachability. Forward reachability is useful for
 * questions with a tight source constraint, e.g. "find me packets send from node A that get
 * dropped". When reasoning about many sources simultaneously, we have to somehow remember the
 * source, which is very expensive for a large number of sources. For queries that have to consider
 * all packets that can reach the query state, backward reachability is much more efficient.
 */
public class BDDReachabilityAnalysis {
  private final BDDPacket _bddPacket;

  // preState --> postState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _edges;

  // postState --> preState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _reverseEdges;

  // stateExprs that correspond to the IngressLocations of interest
  private final ImmutableSet<StateExpr> _ingressLocationStates;

  private final BDD _queryHeaderSpaceBdd;

  BDDReachabilityAnalysis(
      BDDPacket packet,
      Set<StateExpr> ingressLocationStates,
      Map<StateExpr, Map<StateExpr, Edge>> edges,
      BDD queryHeaderSpaceBdd) {
    _bddPacket = packet;
    _edges = edges;
    _reverseEdges = computeReverseEdges(_edges);
    _ingressLocationStates = ImmutableSet.copyOf(ingressLocationStates);
    _queryHeaderSpaceBdd = queryHeaderSpaceBdd;
  }

  private static Map<StateExpr, Map<StateExpr, Edge>> computeReverseEdges(
      Map<StateExpr, Map<StateExpr, Edge>> edges) {
    Map<StateExpr, Map<StateExpr, Edge>> reverseEdges = new HashMap<>();
    edges.forEach(
        (preState, preStateOutEdges) ->
            preStateOutEdges.forEach(
                (postState, edge) ->
                    reverseEdges
                        .computeIfAbsent(postState, k -> new HashMap<>())
                        .put(preState, edge)));
    // freeze
    return toImmutableMap(
        reverseEdges, Entry::getKey, entry -> ImmutableMap.copyOf(entry.getValue()));
  }

  private Map<StateExpr, BDD> computeReverseReachableStates() {
    Map<StateExpr, BDD> reverseReachableStates = new HashMap<>();
    Set<StateExpr> dirty = new HashSet<>();

    reverseReachableStates.put(Query.INSTANCE, _queryHeaderSpaceBdd);
    dirty.add(Query.INSTANCE);

    while (!dirty.isEmpty()) {
      Set<StateExpr> newDirty = new HashSet<>();

      dirty.forEach(
          postState -> {
            Map<StateExpr, Edge> postStateInEdges = _reverseEdges.get(postState);
            if (postStateInEdges == null) {
              // postState has no in-edges
              return;
            }

            BDD postStateBDD = reverseReachableStates.get(postState);
            postStateInEdges.forEach(
                (preState, edge) -> {
                  BDD result = edge.traverseBackward(postStateBDD);
                  if (result.isZero()) {
                    return;
                  }

                  // update preState BDD reverse-reachable from leaf
                  BDD oldReach = reverseReachableStates.get(preState);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);
                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reverseReachableStates.put(preState, newReach);
                    newDirty.add(preState);
                  }
                });
          });

      dirty = newDirty;
    }

    return ImmutableMap.copyOf(reverseReachableStates);
  }

  public void detectLoops() {
    BDD one = _bddPacket.getFactory().one();
    BDD zero = _bddPacket.getFactory().zero();
    Map<StateExpr, BDD> reachableInNRounds =
        toImmutableMap(_ingressLocationStates, Function.identity(), k -> one);

    long numEdges = true ? 2000 : _edges.values().stream().mapToLong(m -> m.values().size()).sum();
    long time = System.currentTimeMillis();
    for (int round = 0; !reachableInNRounds.isEmpty() && round < numEdges; round++) {
      reachableInNRounds = propagate(reachableInNRounds);
    }
    time = System.currentTimeMillis() - time;

    if (!reachableInNRounds.isEmpty()) {
      /*
       * Loop! At least one of the entries in reachableInNRounds is part of a loop. The others are
       * offshoots of a loop. We want to distinguish between them. One way is to do DFS from each
       * to try to find itself. Another is to
       */
      long confirmTime = System.currentTimeMillis();
      Map<StateExpr, BDD> confirmedLoops =
          reachableInNRounds
              .entrySet()
              .stream()
              // .filter(entry -> confirmLoop(entry.getKey(), entry.getValue(), numEdges))
              .filter(entry -> confirmLoopFW(entry.getKey(), entry.getValue()))
              .collect(ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue));
      confirmTime = System.currentTimeMillis() - confirmTime;
      return;
    } else {
      return;
    }
  }

  public Map<StateExpr, BDD> propagate(Map<StateExpr, BDD> bdds) {
    BDD zero = _bddPacket.getFactory().zero();
    Map<StateExpr, BDD> newReachableInNRounds = new HashMap<>();
    bdds.forEach(
        (source, sourceBdd) ->
            _edges
                .getOrDefault(source, ImmutableMap.of())
                .forEach(
                    (target, edge) -> {
                      BDD targetBdd = newReachableInNRounds.getOrDefault(target, zero);
                      BDD newTragetBdd = targetBdd.or(edge.traverseForward(sourceBdd));
                      if (!newTragetBdd.isZero()) {
                        newReachableInNRounds.put(target, newTragetBdd);
                      }
                    }));
    return newReachableInNRounds;
  }

  private boolean confirmLoop(StateExpr stateExpr, BDD bdd, long rounds) {
    Map<StateExpr, BDD> bdds = propagate(ImmutableMap.of(stateExpr, bdd));

    BDD zero = _bddPacket.getFactory().zero();
    for (int i = 0; i < rounds; i++) {
      if (bdds.isEmpty()) {
        return false;
      }
      bdds = propagate(bdds);
      BDD bdd1 = bdds.getOrDefault(stateExpr, zero);
      if (!bdd1.and(bdd).isZero()) {
        // non-empty intersection, so there's a loop.
        // if bdd1 is contained in bdd, then it's an infinite loop
        // if it's a partial intersection, it could be a non-infinite loop (though we don't
        // currently support the transformations necessary to make those).
        return true;
      }
    }

    return false;
    // throw new BatfishException("Shouldn't happen!");
  }

  /**
   * Run Floyd-Warshall from one step past the initial state. Each round, check if the initial state
   * has been reached yet.
   */
  private boolean confirmLoopFW(StateExpr stateExpr, BDD bdd) {
    Map<StateExpr, BDD> reachable = propagate(ImmutableMap.of(stateExpr, bdd));
    Set<StateExpr> dirty = new HashSet<>(reachable.keySet());

    int rounds = 0;
    BDD zero = _bddPacket.getFactory().zero();
    while (!dirty.isEmpty()) {
      rounds += 1;
      Set<StateExpr> newDirty = new HashSet<>();

      dirty.forEach(
          preState -> {
            Map<StateExpr, Edge> preStateOutEdges = _edges.get(preState);
            if (preStateOutEdges == null) {
              // preState has no out-edges
              return;
            }

            BDD preStateBDD = reachable.get(preState);
            preStateOutEdges.forEach(
                (postState, edge) -> {
                  BDD result = edge.traverseBackward(preStateBDD);
                  if (result.isZero()) {
                    return;
                  }

                  // update postState BDD reverse-reachable from leaf
                  BDD oldReach = reachable.getOrDefault(postState, zero);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);
                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reachable.put(postState, newReach);
                    newDirty.add(postState);
                  }
                });
          });

      dirty = newDirty;
      if (dirty.contains(stateExpr)) {
        if (!reachable.get(stateExpr).and(bdd).isZero()) {
          return true;
        }
      }
    }
    return false;
  }

  public BDDPacket getBDDPacket() {
    return _bddPacket;
  }

  public Map<IngressLocation, BDD> getIngressLocationReachableBDDs() {
    BDD zero = _bddPacket.getFactory().zero();
    Map<StateExpr, BDD> reverseReachableStates = computeReverseReachableStates();
    return _ingressLocationStates
        .stream()
        .collect(
            ImmutableMap.toImmutableMap(
                BDDReachabilityAnalysis::toIngressLocation,
                root -> reverseReachableStates.getOrDefault(root, zero)));
  }

  @VisibleForTesting
  static IngressLocation toIngressLocation(StateExpr stateExpr) {
    Preconditions.checkArgument(
        stateExpr instanceof OriginateVrf || stateExpr instanceof OriginateInterfaceLink);

    if (stateExpr instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) stateExpr;
      return IngressLocation.vrf(originateVrf.getHostname(), originateVrf.getVrf());
    } else {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) stateExpr;
      return IngressLocation.interfaceLink(
          originateInterfaceLink.getHostname(), originateInterfaceLink.getIface());
    }
  }

  @VisibleForTesting
  Map<StateExpr, Map<StateExpr, Edge>> getEdges() {
    return _edges;
  }
}
