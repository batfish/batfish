package org.batfish.bddreachability;

import static org.batfish.common.util.CommonUtil.toImmutableMap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Suppliers;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.sf.javabdd.BDD;
import org.batfish.common.BatfishException;
import org.batfish.common.bdd.BDDOps;
import org.batfish.common.bdd.BDDPacket;
import org.batfish.datamodel.Flow;
import org.batfish.datamodel.Flow.Builder;
import org.batfish.z3.IngressLocation;
import org.batfish.z3.expr.StateExpr;
import org.batfish.z3.state.Accept;
import org.batfish.z3.state.Drop;
import org.batfish.z3.state.NeighborUnreachable;
import org.batfish.z3.state.OriginateInterfaceLink;
import org.batfish.z3.state.OriginateVrf;
import org.batfish.z3.state.PostInVrf;
import org.batfish.z3.state.PreInInterface;
import org.batfish.z3.state.visitors.DefaultTransitionGenerator;

/**
 * A new reachability analysis engine using BDDs. The analysis maintains a graph that describes how
 * packets flow through the network and through logical phases of a router. The graph is similar to
 * the one generated by {@link DefaultTransitionGenerator} for reachability analysis using NOD. In
 * particular, the graph nodes are {@link StateExpr StateExprs} and the edges are mostly the same as
 * the NOD program rules/transitions. {@link BDD BDDs} label the nodes and edges of the graph. A
 * node label represent the set of packets that can reach that node, and an edge label represents
 * the set of packets that can traverse the edge.
 *
 * <p>The two main departures from the NOD program are: 1) ACLs are encoded as a single BDD that
 * labels an edge (rather than a series of states/transitions in NOD programs). 2) Source NAT is
 * handled differently -- we don't maintain separate original and current source IP variables.
 * Instead, we keep track of where/how the packet is transformed as it flows through the network,
 * and reconstruct it after the fact. This requires some work that can't be expressed in BDDs.
 *
 * <p>We currently implement backward all-pairs reachability. Forward reachability is useful for
 * questions with a tight source constraint, e.g. "find me packets send from node A that get
 * dropped". When reasoning about many sources simultaneously, we have to somehow remember the
 * source, which is very expensive for a large number of sources. Something like multipath
 * consistency -- "find me a packet and a node such that when the node sends the packet, it can be
 * either accepted and dropped" -- for which there are many sources but only a few sinks ({@link
 * Accept}, {@link Drop}, and {@link NeighborUnreachable}), backward reachability is much more
 * efficient. We still have to remember the sinks, but there's only ever 3 of those, no matter how
 * many sources there are.
 */
public class BDDReachabilityAnalysis {
  private final BDDPacket _bddPacket;

  // preState --> postState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _edges;

  // postState --> preState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _reverseEdges;

  private final Map<StateExpr, BDD> _graphRoots;

  // state --> final state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _reverseReachableStates;

  // for NAT
  private final BDD _srcIpVars;

  private Set<StateExpr> _leafStates;

  BDDReachabilityAnalysis(
      BDDPacket packet,
      Map<StateExpr, BDD> graphRoots,
      Map<StateExpr, Map<StateExpr, Edge>> transitions) {
    _bddPacket = packet;
    _edges = computeEdges(graphRoots, transitions);
    _reverseEdges = computeReverseEdges(_edges);
    _graphRoots = ImmutableMap.copyOf(graphRoots);
    _reverseReachableStates = Suppliers.memoize(this::computeReverseReachableStates);
    _leafStates = computeTerminalStates();
    _srcIpVars = new BDDOps(_bddPacket.getFactory()).and(_bddPacket.getSrcIp().getBitvec());
  }

  private static Map<StateExpr, Map<StateExpr, Edge>> computeEdges(
      Map<StateExpr, BDD> graphRoots, Map<StateExpr, Map<StateExpr, Edge>> transitions) {
    Map<StateExpr, Map<StateExpr, Edge>> edges = new HashMap<>();
    // add root transitions
    graphRoots.forEach(
        (root, predicate) -> {
          if (root instanceof OriginateVrf) {
            OriginateVrf originateVrf = (OriginateVrf) root;
            PostInVrf postInVrf = new PostInVrf(originateVrf.getHostname(), originateVrf.getVrf());
            Edge edge = new Edge(root, postInVrf, predicate);
            edges.put(originateVrf, ImmutableMap.of(postInVrf, edge));
          } else if (root instanceof OriginateInterfaceLink) {
            OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) root;
            PreInInterface preInInterface =
                new PreInInterface(
                    originateInterfaceLink.getHostname(), originateInterfaceLink.getIface());
            Edge edge = new Edge(root, preInInterface, predicate);
            edges.put(originateInterfaceLink, ImmutableMap.of(preInInterface, edge));
          } else {
            throw new BatfishException("unexpected graph root: " + root);
          }
        });
    // add all other transitions
    transitions.forEach(edges::put);
    return ImmutableMap.copyOf(edges);
  }

  private static Map<StateExpr, Map<StateExpr, Edge>> computeReverseEdges(
      Map<StateExpr, Map<StateExpr, Edge>> edges) {
    Map<StateExpr, Map<StateExpr, Edge>> reverseEdges = new HashMap<>();
    edges.forEach(
        (preState, preStateOutEdges) ->
            preStateOutEdges.forEach(
                (postState, edge) ->
                    reverseEdges
                        .computeIfAbsent(postState, k -> new HashMap<>())
                        .put(preState, edge)));
    // freeze
    return toImmutableMap(
        reverseEdges, Entry::getKey, entry -> ImmutableMap.copyOf(entry.getValue()));
  }

  /*
   * node --> final --> set of headers that can reach final from node.
   */
  private Map<StateExpr, Map<StateExpr, BDD>> computeReverseReachableStates() {
    List<StateExpr> leaves =
        ImmutableList.of(Accept.INSTANCE, Drop.INSTANCE, NeighborUnreachable.INSTANCE);
    return computeReverseReachableStates(leaves);
  }

  private Map<StateExpr, Map<StateExpr, BDD>> computeReverseReachableStates(
      List<StateExpr> leaves) {
    Map<StateExpr, Map<StateExpr, BDD>> reverseReachableStates = new HashMap<>();
    Multimap<StateExpr, StateExpr> dirty = HashMultimap.create();
    for (StateExpr leaf : leaves) {
      reverseReachableStates.put(leaf, ImmutableMap.of(leaf, _bddPacket.getFactory().one()));
      dirty.put(leaf, leaf);
    }

    List<Long> roundTimes = new LinkedList<>();
    List<Integer> roundDirties = new LinkedList<>();

    while (!dirty.isEmpty()) {
      Multimap<StateExpr, StateExpr> newDirty = HashMultimap.create();
      long time = System.currentTimeMillis();

      dirty.forEach(
          (postState, leaf) -> {
            Map<StateExpr, Edge> postStateInEdges = _reverseEdges.get(postState);
            if (postStateInEdges == null) {
              // preState has no in-edges
              return;
            }

            BDD postStateBDD = reverseReachableStates.get(postState).get(leaf);
            postStateInEdges.forEach(
                (preState, edge) -> {
                  BDD constraint = edge.getConstraint();
                  BDD result = constraint == null ? postStateBDD : postStateBDD.and(constraint);
                  if (result.isZero()) {
                    return;
                  }

                  // apply source nat backward
                  List<BDDSourceNat> sourceNats = edge.getSourceNats();
                  if (sourceNats != null) {
                    BDD orig = result;
                    BDD origExistSrcIp = orig.exist(_srcIpVars);
                    // non-natted case: srcIp unchanged, none of the lines match
                    result =
                        sourceNats
                            .stream()
                            .map(srcNat -> srcNat._condition.not())
                            .reduce(orig, BDD::and);
                    // natted cases
                    for (BDDSourceNat sourceNat : sourceNats) {
                      if (!orig.and(sourceNat._updateSrcIp).isZero()) {
                        // this could be the NAT rule that was applied
                        result = result.or(origExistSrcIp.and(sourceNat._condition));
                      }
                    }
                    assert !result.isZero();
                  }

                  // update preState BDD reverse-reachable from leaf
                  Map<StateExpr, BDD> reverseReachPreState =
                      reverseReachableStates.computeIfAbsent(preState, k -> new HashMap<>());
                  BDD oldReach = reverseReachPreState.get(leaf);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);

                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reverseReachPreState.put(leaf, newReach);
                    newDirty.put(preState, leaf);
                  }
                });
          });

      dirty = newDirty;

      time = System.currentTimeMillis() - time;
      roundTimes.add(time);
      roundDirties.add(dirty.size());
    }

    return toImmutableMap(
        reverseReachableStates,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Set<StateExpr> computeTerminalStates() {
    Set<StateExpr> preStates = _edges.keySet();
    Set<StateExpr> postStates =
        _edges.values().stream().flatMap(m -> m.keySet().stream()).collect(Collectors.toSet());
    return ImmutableSet.copyOf(Sets.difference(postStates, preStates));
  }

  /**
   * Return a list of {@link MultipathInconsistency multipath consistency violations} detected in
   * the network.
   */
  @VisibleForTesting
  List<MultipathInconsistency> computeMultipathInconsistencies() {
    return _reverseReachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> _graphRoots.containsKey(entry.getKey()))
        .flatMap(
            entry -> {
              StateExpr root = entry.getKey();
              Map<StateExpr, BDD> leafBDDs = entry.getValue();
              return _leafStates
                  .stream()
                  .filter(leafBDDs::containsKey)
                  .flatMap(
                      leaf1 -> {
                        BDD leaf1BDD = leafBDDs.get(leaf1);
                        return _leafStates
                            .stream()
                            .filter(leaf2 -> leaf1 != leaf2)
                            .filter(leafBDDs::containsKey)
                            // avoid duplicate violations
                            .filter(leaf2 -> leaf1.toString().compareTo(leaf2.toString()) < 1)
                            .flatMap(
                                leaf2 -> {
                                  BDD leaf2BDD = leafBDDs.get(leaf2);
                                  BDD intersection = leaf1BDD.and(leaf2BDD);
                                  return intersection.isZero()
                                      ? Stream.empty()
                                      : Stream.of(
                                          new MultipathInconsistency(
                                              root, ImmutableSet.of(leaf1, leaf2), intersection));
                                });
                      });
            })
        .collect(ImmutableList.toImmutableList());
  }

  public Map<IngressLocation, BDD> getIngressLocationAcceptBDDs() {
    return _reverseReachableStates
        .get()
        .entrySet()
        .stream()
        .filter(
            entry ->
                entry.getKey() instanceof OriginateInterfaceLink
                    || entry.getKey() instanceof OriginateVrf)
        .collect(
            ImmutableMap.toImmutableMap(
                entry -> toIngressLocation(entry.getKey()),
                entry -> entry.getValue().get(Accept.INSTANCE)));
  }

  private static IngressLocation toIngressLocation(StateExpr stateExpr) {
    Preconditions.checkArgument(
        stateExpr instanceof OriginateVrf || stateExpr instanceof OriginateInterfaceLink);

    if (stateExpr instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) stateExpr;
      return IngressLocation.vrf(originateVrf.getHostname(), originateVrf.getVrf());
    } else {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) stateExpr;
      return IngressLocation.interfaceLink(
          originateInterfaceLink.getHostname(), originateInterfaceLink.getIface());
    }
  }

  Set<StateExpr> getLeafStates() {
    return _leafStates;
  }

  public Set<Flow> multipathInconsistencies(String flowTag) {
    return computeMultipathInconsistencies()
        .stream()
        .map(violation -> multipathInconsistencyToFlow(violation, flowTag))
        .collect(ImmutableSet.toImmutableSet());
  }

  @VisibleForTesting
  Flow multipathInconsistencyToFlow(MultipathInconsistency violation, String flowTag) {
    Builder fb =
        _bddPacket
            .getFlow(violation.getBDD())
            .orElseGet(
                () -> {
                  throw new BatfishException("MultipathConsistencyViolation with UNSAT predicate");
                });
    StateExpr originateState = violation.getOriginateState();
    fb.setTag(flowTag);
    if (originateState instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) originateState;
      fb.setIngressNode(originateVrf.getHostname());
      fb.setIngressVrf(originateVrf.getVrf());
    } else if (originateState instanceof OriginateInterfaceLink) {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) originateState;
      fb.setIngressNode(originateInterfaceLink.getHostname());
      fb.setIngressInterface(originateInterfaceLink.getIface());
    } else {
      throw new BatfishException(
          "Unexpected originateState type: " + originateState.getClass().getSimpleName());
    }
    return fb.build();
  }
}
